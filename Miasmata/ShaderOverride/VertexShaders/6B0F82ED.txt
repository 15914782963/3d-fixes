//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
    vs_3_0
    def c0, 0.5, 1, 0, 0
    dcl_position v0
    dcl_texcoord v1
    dcl_position o0
    dcl_texcoord o1.xy

def c220, 0, 1, 0.0625, 0.5
def c221, 64, 0.015625, 1.4, 0
dcl_2d s0
dcl_2d s3 // refr_sampler copied from water pixel shader

// For loop to improve stereo cursor accuracy:
defi i0, 255, 0, 0, 0
def c227, 0.00390625, 0, 0, 0.5 // 1/i0.x, 0.5

    mov r0.xy, v0
    mov r0.zw, c0.xyxy
    mov o1.xy, v1

texldl r31, c220.z, s0

mov r30, c250
mov r25.x, c251.x

// Test the input Z value to avoid adjusting the tutorial background, which
// appears to be rendered to another UI texture which is then rendered to the
// screen - if we adjust it both times it moves 2x too far. Lucky for us the
// input Z value seems to be non-zero for the tutorial background.
if_eq v0.z, c220.x
	if_eq r30.y, c220.y // Depth buffer is currently valid (not in a menu)
		if_ne r30.w, c220.x // Stereo cursor depth override
			mad r0.x, r31.x, r30.w, r0.x
		else
			// Adjust cursor depth based on the W component of the refr_sampler copied from
			// the water shader, which has the scene depth.
			// How do I know this? The water was the only surface with a halo around nearer
			// objects, which suggests it had access to the depth buffer in some way (it
			// would use this to calculate the water opacity based on depth). None of the
			// sampler names sounded promising, so I determined that the texkill
			// instruction caused the halo (removing it removed the halo), so from there it
			// was a simple matter of looking at the samplers that provided input to that
			// instruction and directly outputing the contents of the sampler to identify
			// the channel with the depth information.

			// Stereo cursor: To improve the accuracy of the stereo cursor, we start at the
			// center of the screen and work our way towards center + separation (ideally
			// we would loop one pixel at a time, but as the loop counts must be constant
			// we can't do that here, so we just choose a granuality in i0 and c227.
			// Alternatively we could loop one pixel at a time with a hardcoded maximum
			// number of pixels)

			mov r20.w, c221.z		// Minimum distance to test
			add r31.w, r20.w, -r31.y	// near - convergence
			mad r20.x, r31.w, r31.x, c220.w	// X sample coord = center + separation * (near - convergence)
			mov r20.y, c220.w		// Y sample coord = center
			add r20.z, r20.x, -c220.w	// Z = X offset from center
			add r31.z, r31.x, -r20.z	// Total distance to cover (separation - starting X offset)

			mov r21, r20			// Working copy
			mul r31.w, r31.x, r31.y		// separation * convergence (precompute this constant)
			rep i0
				mad r21.z, r31.z, c227.x, r21.z	// adjustment += (total distance to cover) / i0.x (granuality)

				// Calculate W for this adjustment amount:
				add r21.w, r31.x, -r21.z	// separation - adjustment
				rcp r21.w, r21.w
				mul r21.w, r31.w, r21.w		// w = (separation * convergence) / (separation - adjustment)

				// Read depth texture at this pixel (divide by 2 for texture coordinates):
				mad r21.x, r21.z, c220.w, c220.w // X = 0.5 + adjustment/2
				texldl r5, r21.xy, s3

				// Ignore reads of 0 - can happen on the water at the edge of the map
				if_ne r5.w, c220.x

					// scale depth buffer to world Z (game dependent - look for scaling applied to
					// the depth buffer wherever else it is used. In this case multiply by 64):
					mul r5.w, r5.w, c221.x

					// If the sampled depth is closer than the calculated depth, exit the loop:
					break_ge r21.w, r5.w

				endif

				// Set the output depth to this pixel
				mov r20, r21
			endrep

			// Finally adjust the X coordinate:
			add r0.x, r0.x, r20.z
		endif
	endif
endif

mov o0, r0
