// UI - stat bars

//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
// Parameters:
//
//   float4 BatchFloat[192];
//
//
// Registers:
//
//   Name         Reg   Size
//   ------------ ----- ----
//   BatchFloat   c6     192
//

    vs_3_0
    def c0, 1020.03998, 2, 0, 0
    dcl_position v0
    dcl_color v1
    dcl_color1 v2
    dcl_color o0
    dcl_color1 o1
    dcl_texcoord3 o2
    dcl_texcoord4 o3
    dcl_position o4

dcl_2d s2 // Copy of SceneColorTexture, depth is in w
defi i0, 255, 0, 0, 0
def c227, 0.00390625, 64, 0, 0.5 // 1/i0.x, 0.5

dcl_2d s3 // Stereo sampler
def c220, 0, 1, 0.0625, 0.5
def c221, 2, 0.001, 1920, 1080

    mad r0.x, v2.z, c0.x, c0.y
    mul r0.y, c0.x, v2.z
    frc r0.y, r0.y
    add r0.x, r0.x, -r0.y
    mad r0.y, v2.z, c0.x, -r0.y
    mova a0.xy, r0.yxzw
    dp4 r2.x, v0, c6[a0.y]
    dp4 r2.y, v0, c9[a0.x]
    mov o0, v1
    mov o1, v2
    mov o2, c6[a0.x]
    mov o3, c7[a0.x]
    mov r2.zw, v0

texldl r31, c220.z, s3

mov r30.x, c220.x

// Only enable auto depth if MinZ_MaxZRatio is valid:
mov r30.w, c150.x
if_ne r30.w, c220.x
	mov r30.x, c220.y
endif

if_eq r30.x, c220.y
	// Auto depth: sample a number of points on the depth buffer to
	// determine an appropriate depth for this object, starting at the near
	// clipping plane and working towards original x + separation.
	//
	// You can think of this as a line in three dimensional space that
	// starts at each eye and stretches out towards infinity. We sample 255
	// points along this line (evenly spaced in the X axis) and compare
	// with the depth buffer to find where the line is first intersected.
	//
	// Based on DarkStarSword's stereo crosshair code originally developed
	// for Miasmata, adapted to HLSL and made to use coordinates other than
	// (0,0), then adapted back to assembly for UE3.

	// Option 1: Adjust from current vertex position:
	//rcp r22.w, r2.w
	//mul r22.xy, r2.xy, r22.w

	// Option 2: Adjust from mouse cursor position:
	rcp r22.x, c210.x		// 1 / resolution
	rcp r22.y, c210.y		// 1 / resolution
	mul r22.xy, r22.xy, c180.xy	// mouse / resolution
	add r22.xy, r22.xy, -c220.ww	// ... - 0.5
	mul r22.xy, r22.xy, c221.xx	// ... * 2
	mov r22.y, -r22.y		// Negate Y

	// near = -MinZ_MaxZRatio.x / MinZ_MaxZRatio.y
	rcp r31.w, c150.y
	mul r20.w, -c150.x, r31.w

	// offset = separation * (near - convergence) / near
	add r31.w, r20.w, -r31.y
	mul r20.x, r31.w, r31.x
	rcp r31.w, r20.w
	mul r20.x, r20.x, r31.w

	// Total distance to cover
	// distance = separation - starting X offset:
	add r20.y, r31.x, -r20.x

	// old_offset = offset
	mov r21.x, r20.x

	// Precompute some constants:
	// separation * convergence:
	mul r31.w, r31.x, r31.y
	// distance / 255:
	mul r20.z, r20.y, c227.x

	rep i0
		// offset += distance / 255:
		add r20.x, r20.x, r20.z

		// Calculate W for this adjustment amount:
		// w = (separation * convergence) / (separation - offset):
		add r20.w, r31.x, -r20.x
		rcp r20.w, r20.w
		mul r20.w, r31.w, r20.w

		// sample_x = x + offset, sample_y = -y
		mov r23.y, -r22.y
		add r23.x, r22.x, r20.x
		// Convert to texture coordinates (coords / 2 + 0.5):
		mad r23.xy, r23.xy, c220.w, c220.w
		// Sample depth buffer:
		texldl r5, r23.xy, s2

		// Ignore reads of 1.0:
		if_ne r5.w, c220.y
			// scale depth buffer to world Z (game dependent - look for scaling applied to
			// the depth buffer wherever else it is used. In the case of UE3 we use
			// MinZ_MaxZRatio):
			mov r5.y, c220.y
			add r5.x, r5.y, -c150.y
			add r5.x, -r5.x, r5.w
			rcp r5.x, r5.x
			mul r5.x, r5.x, -c150.x

			// If the sampled depth is closer than the calculated depth, exit the loop:
			break_ge r20.w, r5.x
		endif

		// old_offset = offset
		mov r21.x, r20.x
	endrep

	// Finally adjust the X coordinate:
	mad r2.x, r21.x, r2.w, r2.x
endif

mov o4, r2

// approximately 13 instruction slots used
