// CRC32: B8C7EDC5 | Unity headers extracted from Font.shader
// Shader "GUI/Text Shader" {
//   Properties {
//    _MainTex ("Font Texture", 2D) = "white" { }
//    _Color ("Text Color", Color) = (1,1,1,1)
//   }
//   SubShader 1/1 {
//     Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" "PreviewType"="Plane" }
//     Pass 1/1 {
//       Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" "PreviewType"="Plane" }
//       ZTest Always
//       ZWrite Off
//       Cull Off
//       Blend SrcAlpha OneMinusSrcAlpha
//       GpuProgramID 16679
//       Program "vp" {
//         SubProgram "d3d9 " {
//           Bind "vertex" Vertex
//           Bind "color" Color
//           Bind "texcoord" TexCoord0
//           Matrix 0 [glstate_matrix_mvp]
//           Vector 5 [_Color]
//           Vector 4 [_MainTex_ST]
//         }
//       }
//     }
//   }
// }
// 
// Headers extracted with DarkStarSword's extract_unity_shaders.py
// https://raw.githubusercontent.com/DarkStarSword/3d-fixes/master/extract_unity_shaders.py

    vs_3_0 // Converted from vs_2_0 with DarkStarSword's shadertool.py
    dcl_position v0
    dcl_color v1
    dcl_texcoord v2

dcl_texcoord o0
dcl_position o1
dcl_color o2

def c220, 0, 1, 0.0625, 0.5

// For the auto HUD depth:
dcl_2d s2 // Copy of _CameraDepthTexture
defi i0, 255, 0, 0, 0
def c227, 0.00390625, 64, 0, 0.5 // 1/i0.x, 0.5

    dp4 r0.x, c0, v0
    dp4 r0.y, c1, v0
    dp4 r0.z, c2, v0
    dp4 r0.w, c3, v0
    mul o2, v1, c5
    mad o0.xy, v2, c4, c4.zwzw

// Only adjust when originally drawn at screen depth:
if_eq r0.w, c220.y

	// Auto depth: sample a number of points on the depth buffer to
	// determine an appropriate depth for this object, starting at the near
	// clipping plane and working towards original x + separation.
	//
	// You can think of this as a line in three dimensional space that
	// starts at each eye and stretches out towards infinity. We sample 255
	// points along this line (evenly spaced in the X axis) and compare
	// with the depth buffer to find where the line is first intersected.
	//
	// Based on DarkStarSword's stereo crosshair code originally developed
	// for Miasmata, adapted to HLSL and made to use coordinates other than
	// (0,0), then adapted back to assembly for UE3.

	// This variant uses the undocumented stereo register injected by the
	// driver instead of the Helix Mod stereo sampler

	// Screen depth coordinates to sample around - Several icons are drawn
	// simultaneously, so we cannot use the first vertex position like we
	// do in Dreamfall Chapters. Instead we just use the current vertex
	// position, which can cause the icon to stretch, but it's better than
	// the alternatives. We could maybe force the game to DX11 and use
	// 3DMigoto's vertex buffer copying support to solve this like Far Cry 4.
	//mov r23, c170
	//dp4 r22.x, c0, r23
	//dp4 r22.y, c1, r23
	mov r22, r0

	// near clipping plane - for Unity we get this from _ZBufferParams
	rcp r20.w, c150.w

	// offset = separation * (near - convergence) / near
	mad r20.x, r20.w, c255.y, c255.x
	rcp r31.w, r20.w
	mul r20.x, r20.x, r31.w

	// Total distance to cover
	// distance = separation - starting X offset:
	add r20.y, c255.y, -r20.x

	// old_offset = offset
	mov r21.x, r20.x

	// Precompute some constants:
	// distance / 255:
	mul r20.z, r20.y, c227.x

	rep i0
		// offset += distance / 255:
		add r20.x, r20.x, r20.z

		// Calculate W for this adjustment amount:
		// w = (separation * convergence) / (separation - offset):
		add r20.w, c255.y, -r20.x
		rcp r20.w, r20.w
		mul r20.w, -c255.x, r20.w

		// sample_x = x + offset, sample_y = y (not flipped compared to UE3)
		mov r23.y, r22.y
		add r23.x, r22.x, r20.x
		// Convert to texture coordinates (coords / 2 + 0.5):
		mad r23.xy, r23.xy, c220.w, c220.w
		// Sample depth buffer:
		texldl r5, r23.xy, s2

		// scale depth buffer to world Z (game dependent - look for scaling applied to
		// the depth buffer wherever else it is used. In the case of Unity we use
		// _ZBufferParams):
		mad r5.x, r5.x, c150.x, c150.y
		add r5.y, c150.z, c150.w // Derive 1/far from _ZBufferParams
		mul r5.x, r5.x, r5.y
		rcp r5.x, r5.x

		// If the sampled depth is closer than the calculated depth, exit the loop:
		break_ge r20.w, r5.x

		// old_offset = offset
		mov r21.x, r20.x
	endrep

	// Finally adjust the X coordinate:
	add r0.x, r0.x, r21.x
endif

mov o1, r0
