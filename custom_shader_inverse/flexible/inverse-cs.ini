; Step 1: Set to the constant buffer containing the matrix you wish to inverse:
[ResourceInverseIn]

[Constants]
; Step 2: Set to the offset within the constant buffer of the matrix you are inversing:
global $matrix_offset

; Step 3: Run the inverse shader. Choose one slot for each unique matrix you
; are inversing as each of these will only run once per frame (adding more if
; necessary):
[CustomShaderInverseSlot1]
max_executions_per_frame = 1
run = CustomShaderInverseUnlimited
ResourceInverseOutCBSlot1 = ref ResourceInverseOutCB
[CustomShaderInverseSlot2]
max_executions_per_frame = 1
run = CustomShaderInverseUnlimited
ResourceInverseOutCBSlot2 = ref ResourceInverseOutCB

; Step 4: Your inversed matrix is available in these constant buffers at offset 0:
[ResourceInverseOutCBSlot1]
[ResourceInverseOutCBSlot2]


; Internals - not recommended to use directly because it doesn't have any
; per-frame limits.
[ResourceInverseOutUAV]
type = RWBuffer
format = R32G32B32A32_FLOAT
array = 4
[ResourceInverseOutCB]
[ResourceInverseBak]
[CustomShaderInverseUnlimited]
cs = inverse-cs.hlsl

ResourceInverseBak = ref cs-cb0
local $bak_x = x

cs-cb0 = ResourceInverseIn
cs-u0 = ResourceInverseOutUAV
x = $matrix_offset

dispatch = 1, 1, 1

post ResourceInverseOutCB = copy ResourceInverseOutUAV

post x = $bak_x
post cs-cb0 = ref ResourceInverseBak
post cs-u0 = null

;Resource\ShaderFixes\debug_cb.ini\DebugCB = ResourceInverseIn
;Resource\ShaderFixes\debug_cb.ini\DebugCB = ResourceInverseOutCB
