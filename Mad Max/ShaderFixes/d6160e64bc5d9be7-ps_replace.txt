// Bloom around lights
// VS e9849e745227d124

cbuffer GlobalConstants : register(b0)
{
  float4 Globals[17] : packoffset(c0);
  float4 LightPositions[65] : packoffset(c17);
  float4 LightColors[65] : packoffset(c82);
}

cbuffer cbInstanceConsts : register(b1)
{
  float4 InstanceConsts[2] : packoffset(c0);
}
SamplerState DiffuseTexture_s : register(s0);
SamplerState DepthTexture_s : register(s1);
Texture2D<float4> DiffuseTexture : register(t0);
Texture2D<float4> DepthTexture : register(t1);

Texture2D<float4> StereoParams : register(t125);
Texture1D<float4> IniParams : register(t120);

void main( 
  float4 v0 : SV_Position0,
  float2 v1 : TEXCOORD0,
  float4 v2 : COLOR0,
  out float4 o0 : SV_Target0)
{
  float4 r0,r1;
  uint4 bitmask, uiDest;
  float4 fDest;

  r0.xy = saturate(InstanceConsts[0].xy);

float4 stereo = StereoParams.Load(0);
// Values from frame analysis of other shaders that sample depth buffer and
// scale to world Z:
float depth = 1 / (InstanceConsts[0].z * 9.9999752 + 0.000025);
float correction = stereo.x * (depth - stereo.y) / depth / 2;


// // Debugging, show original depth buffer sample location in red:
// if (abs(v0.x/1920 - r0.x) < 0.01) {
// 	o0 = float4(1,0,0,1);
// 	return;
// }

r0.x += correction;

// // Debugging, show adjusted depth buffer sample location in green:
// if (abs(v0.x/1920 - r0.x) < 0.01) {
// 	o0 = float4(0,1,0,1);
// 	return;
// }

  r0.x = DepthTexture.Sample(DepthTexture_s, r0.xy).x;
  r0.x = r0.x < InstanceConsts[0].z;
  r0.x = r0.x ? 0.500000 : 0;
  r1.xyzw = saturate(Globals[8].zwzw * float4(-3,3.5,3.5,6) + InstanceConsts[0].xyxy);

r1.x += correction;
r1.z += correction;

  r0.y = DepthTexture.Sample(DepthTexture_s, r1.xy).x;
  r0.z = DepthTexture.Sample(DepthTexture_s, r1.zw).x;
  r0.yz = r0.yz < InstanceConsts[0].zz;

// Decompiler bug misinterpreted 0x3e000000:
  //r0.yz = r0.yz ? float2(1.04018739e+009,1.04018739e+009) : 0;
  r0.yz = r0.yz ? float2(0.125, 0.125) : 0;

  r0.x = r0.x + r0.y;
  r0.x = r0.x + r0.z;
  r1.xyzw = saturate(Globals[8].zwzw * float4(-5,-3.5,3,-3) + InstanceConsts[0].xyxy);

r1.x += correction;
r1.z += correction;

  r0.y = DepthTexture.Sample(DepthTexture_s, r1.xy).x;
  r0.z = DepthTexture.Sample(DepthTexture_s, r1.zw).x;
  r0.yz = r0.yz < InstanceConsts[0].zz;

// Decompiler bug misinterpreted 0x3e000000:
  // r0.yz = r0.yz ? float2(1.04018739e+009,1.04018739e+009) : 0;
  r0.yz = r0.yz ? float2(0.125, 0.125) : 0;

  r0.x = r0.x + r0.y;
  r0.x = r0.x + r0.z;
  r1.xyzw = DiffuseTexture.Sample(DiffuseTexture_s, v1.xy).xyzw;
  r1.xyzw = v2.xyzw * r1.xyzw;
  r0.y = log2(r1.w);
  r1.xyz = float3(4,4,4) * r1.xyz;
  r0.y = 1.17999995 * r0.y;
  r1.w = exp2(r0.y);
  o0.xyzw = r1.xyzw * r0.xxxx;
  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Original ASM ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//
// Buffer Definitions: 
//
// cbuffer GlobalConstants
// {
//
//   float4 Globals[17];                // Offset:    0 Size:   272
//   float4 LightPositions[65];         // Offset:  272 Size:  1040 [unused]
//   float4 LightColors[65];            // Offset: 1312 Size:  1040 [unused]
//
// }
//
// cbuffer cbInstanceConsts
// {
//
//   float4 InstanceConsts[2];          // Offset:    0 Size:    32
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// DiffuseTexture                    sampler      NA          NA    0        1
// DepthTexture                      sampler      NA          NA    1        1
// DiffuseTexture                    texture  float4          2d    0        1
// DepthTexture                      texture  float4          2d    1        1
// GlobalConstants                   cbuffer      NA          NA    0        1
// cbInstanceConsts                  cbuffer      NA          NA    1        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Position              0   xyzw        0      POS   float       
// TEXCOORD                 0   xy          1     NONE   float   xy  
// COLOR                    0   xyzw        2     NONE   float   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_Target                0   xyzw        0   TARGET   float   xyzw
//
ps_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb0[9], immediateIndexed
dcl_constantbuffer cb1[1], immediateIndexed
dcl_sampler s0, mode_default
dcl_sampler s1, mode_default
dcl_resource_texture2d (float,float,float,float) t0
dcl_resource_texture2d (float,float,float,float) t1
dcl_input_ps linear v1.xy
dcl_input_ps linear v2.xyzw
dcl_output o0.xyzw
dcl_temps 2
mov_sat r0.xy, cb1[0].xyxx
sample_indexable(texture2d)(float,float,float,float) r0.x, r0.xyxx, t1.xyzw, s1
lt r0.x, r0.x, cb1[0].z
and r0.x, r0.x, l(0x3f000000)
mad_sat r1.xyzw, cb0[8].zwzw, l(-3.000000, 3.500000, 3.500000, 6.000000), cb1[0].xyxy
sample_indexable(texture2d)(float,float,float,float) r0.y, r1.xyxx, t1.yxzw, s1
sample_indexable(texture2d)(float,float,float,float) r0.z, r1.zwzz, t1.yzxw, s1
lt r0.yz, r0.yyzy, cb1[0].zzzz
and r0.yz, r0.yyzy, l(0, 0x3e000000, 0x3e000000, 0)
add r0.x, r0.y, r0.x
add r0.x, r0.z, r0.x
mad_sat r1.xyzw, cb0[8].zwzw, l(-5.000000, -3.500000, 3.000000, -3.000000), cb1[0].xyxy
sample_indexable(texture2d)(float,float,float,float) r0.y, r1.xyxx, t1.yxzw, s1
sample_indexable(texture2d)(float,float,float,float) r0.z, r1.zwzz, t1.yzxw, s1
lt r0.yz, r0.yyzy, cb1[0].zzzz
and r0.yz, r0.yyzy, l(0, 0x3e000000, 0x3e000000, 0)
add r0.x, r0.y, r0.x
add r0.x, r0.z, r0.x
sample_indexable(texture2d)(float,float,float,float) r1.xyzw, v1.xyxx, t0.xyzw, s0
mul r1.xyzw, r1.xyzw, v2.xyzw
log r0.y, r1.w
mul r1.xyz, r1.xyzx, l(4.000000, 4.000000, 4.000000, 0.000000)
mul r0.y, r0.y, l(1.180000)
exp r1.w, r0.y
mul o0.xyzw, r0.xxxx, r1.xyzw
ret 
// Approximately 26 instruction slots used

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
