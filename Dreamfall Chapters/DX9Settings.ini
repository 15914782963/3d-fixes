[General]

; UseRenderedShaders=true is nearly always useful, because it trims the
; list of shaders seen while hunting down to just those active in the
; current scene.  Disable this only if you get crashes during hunting.
UseRenderedShaders=true

; DumpAll will generate ASM text files for every shader seen by the game.
; This is usually worth doing once, but not useful for every run.
DumpAll=true

; Constant registers that will arrive in Vertex and Pixel Shaders, as
; c200.  The constants below will be assigned, based on the key preset.
DefVSConst1 = 200
DefPSConst1 = 200

; The PresetKeysList specifies which KEYs will be used.
; Multiple keys lists are supported.
; Note that the KEY sections are in hexadecimal
PresetsKeysList = 0;1;2;3;4;5;6;7;8;9;A;B;C;D;E;

; Allows textures to be cycled with Up/Down - use to hunt menu text CRC32
; bCalcTexCRCatStart = true

; v1.1.3 update added exclusive full screen mode, so this profile selection is
; no longer necessary:
; GameProfile = fxdplayer

; Mouse stopped working in game with Helix mod (works in menus)
InitMouse = false

; Makes it crash less when reloading shaders:
OverrideMethod = 2

; Allow access to the screen size in pixel shaders for shadow fix:
DefPSViewSizeConst = 210
; Use to calculate appropriate threshold for full-screen coordinate detection:
DefVSViewSizeConst = 210

; Force square surfaces (shadow maps) to be mono:
DefSquareSurfaceMode = 2

; DefDepthStencilSurfaceMode = 1
; DefSurfaceCreationMode = 1
; DefRtCreationMode = 1

; Breaks the light + reflection fixes. I believe this is due to a bug in Helix
; Mod, which causes only one of the two matrix copy slots to be updated each
; frame with this option, rendering the second slot useless.
;CalcMatrixOncePerFrame = true

SurfaceCreationModeList = 0;1;

; Stereoise LightShaft _DepthEpi render target (didn't seem to work)
[SF0]
DefMode = 1
Format = 115
; Width = 1024
; Height = 1024
; Usage = 1
; Pool = 0
; Levels = 1

; Stereoise LightShaft _CoordEpi render target (didn't seem to work)
[SF1]
DefMode = 1
Format = 115
; Width = 1024
; Height = 1024
; Usage = 1
; Pool = 0
; Levels = 1



; Q sets automatic HUD depth for icons and text
; Number row on keyboard sets UI depth to various values between screen depth
; and separation. `~ (left of 1 on US keyboards) sets screen depth, 1-9 sets
; septh in 10% multiples and 0 sets depth to 100% separation.
; Note that the KEY%X on these sections is in hexadecimal, hence we use KEYA
; for the tenth key entry and so on.
[KEY0]
Key = 192
Presets = 0;
Type = 1
[PRES0]
Const3 = 0x00000000
[KEY1]
Key = 49
Presets = 1;
Type = 1
[PRES1]
Const3 = 0x3dcccccd
[KEY2]
Key = 50
Presets = 2;
Type = 1
[PRES2]
Const3 = 0x3e4ccccd
[KEY3]
Key = 51
Presets = 3;
Type = 1
[PRES3]
Const3 = 0x3e99999a
[KEY4]
Key = 52
Presets = 4;
Type = 1
[PRES4]
Const3 = 0x3ecccccd
[KEY5]
Key = 53
Presets = 5;
Type = 1
[PRES5]
Const3 = 0x3f000000
[KEY6]
Key = 54
Presets = 6;
Type = 1
[PRES6]
Const3 = 0x3f19999a
[KEY7]
Key = 55
Presets = 7;
Type = 1
[PRES7]
Const3 = 0x3f333333
[KEY8]
Key = 56
Presets = 8;
Type = 1
[PRES8]
Const3 = 0x3f4ccccd
[KEY9]
Key = 57
Presets = 9;
Type = 1
[PRES9]
Const3 = 0x3f666666
[KEYA]
Key = 48
Presets = A;
Type = 1
[PRESA]
Const3 = 0x3f800000

; U toggles volumetric ray-marched light shafts between:
;   - disabled
;   - no stereo fix
; I tracked down the source code to these - maybe someone can do a better fix:
; https://github.com/robertcupisz/LightShafts
[KEYB]
Key = 85
Presets = B;C;
Type = 1
[PRESB]
Const1 = 0x3f800000
[PRESC]
Const1 = 0x00000000
UseByDef = true

; Q toggles auto HUD depth adjustment
[KEYC]
Key = 81
Presets = D;E;
Type = 1
[PRESD]
Const2 = 0x00000000
[PRESE]
Const2 = 0x3f800000
UseByDef = true

; Default convergence 0.85 on backslash
[KEYD]
Key = 220
Presets = F;
[PRESF]
UseSepSettings = true
SaveSepSettings = true
Convergence = 0x3f47ae14
UseByDef = true


; Copy MVP + M matrices from various sources to allow us to correct world space
; coordinates. We use this instead of the usual Unity lighting fix as we want
; to be able to correct world space coordaintes for reflections, and since
; Helix Mod doesn't have enough copy slots to do both, we change the Unity
; lighting fix to work with world-space coordiantes instead of view-space
; coordinates.
;
; The only time we still need to correct a view-space coordinate is in the
; lighting vertex shader when NOT drawing a full-screen effect, but in that
; case the shader already has a valid MV matrix we can use with the inverted
; MVP matrix to do so.
;
; Thankfully, the MVP matrix is 4x4, so we can use Helix Mod to invert it.

; I now use shadertool to find these instead. Shadertool will add these lines
; to any sections with the relevant matrices during --fix-unity-reflection
; (along with UseMatrix, etc), but it won't add sections for shaders it did not
; apply the reflection fix to. If we find a scene with no shaders it added
; sections for, we could use this to generate sections for shaders that it has
; not fixed (we'd probably want to modify this a little to skip sections
; already in this file).
;
; #!/bin/sh
; 
; # XXX: Blacklist shaders that may use bogus matrices.
; # - SHADOWCASTER - may be rendered from the perspective of a light source
; #
; # - _WorldSpaceCameraPos - We DO use these, but shadertool.py already creates
; #   sections for them during --fix-unity-reflection, so no need to do so here
; #
; # - IGNOREPROJECTOR - No longer blacklisting this, some scenes don't have any
; #   remaining shaders to copy the matrices from if I do (e.g. falling dreamer
; #   in chapter 1). Was never sure if this tag was an indicator of a bogus
; #   matrix or not.
; for x in $(grep -Le '\(_WorldSpaceCameraPos\|SHADOWCASTER\)' *.txt); do
; 	line0=$(head -n 1 $x | sed 's/^[^|]*|//')
; 	line1=$(sed -n 's/^\/\/\s*Matrix \([0-9]\+\) \[glstate_matrix_mvp\]$/GetMatrixFromReg = \1/p' $x|head -n 1)
; 	line2=$(sed -n 's/^\/\/\s*Matrix \([0-9]\+\) \[_Object2World\]\( 3\)\?$/GetMatrixFromReg1 = \1/p' $x|head -n 1)
; 	if [ -n "$line1" -a -n "$line2" ]; then
; 		echo "[VS$(basename $x .txt)]"
; 		echo "; $line0"
; 		echo "$line1"
; 		echo "InverseMatrix = true"
; 		echo "$line2"
; 	fi
; done


; The lighting vertex shader will use it's own MVP and MV matrices to adjust
; the view-space ray. The lighting pixel shaders use the inverse MVP and the
; _Object2World matrices copied from elsewhere to adjust a world-space
; coordinate.




; HUD shaders
[VB2FC2E74B.0]
; Since we are using FirstVertexPosReg in conjunction with DefinedTexturesVS we
; NEED to use the following additional TEX and VB sections. Additionally, since
; we are not using GetVertex in the main shader section, we set it in each
; individual texture section. This allows us to set the HUD depth based on the
; targetting icon, but stop adjusting the HUD when bringing up the selection
; icons, which keeps them all at a consistent depth with each other.
[TEXCAA23431]
; eye
GetVertex = true
VBOffsetList = 0;
[VBCAA23431.0]
[TEXCC3C336C]
; targetting circle
GetVertex = true
VBOffsetList = 0;
[VBCC3C336C.0]
[TEXCD161567]
; cog
GetVertex = true
VBOffsetList = 0;
[VBCD161567.0]
[TEX1DCD05B2]
; talk
GetVertex = true
VBOffsetList = 0;
[VB1DCD05B2.0]
[TEXF7EDA18C]
; door
GetVertex = true
VBOffsetList = 0;
[VBF7EDA18C.0]
[TEXF842EB47]
; hand
GetVertex = true
VBOffsetList = 0;
[VBF842EB47.0]

[VB6AEB3DDF.0]



; Fix for specular highlights, reflections and other effects that are not using
; deferred lighting shaders. These need the world space camera position
; adjusted, which we do by multiplying the adjustment amount by the inversed
; MVP matrix then the _Object2World matrix. These matrices are copied with
; Helix Mod from wherever we can find them (blacklisting certain types of
; shaders that are known to have the wrong matrices, like shadow casters).

; Pixel shaders for matrix sources with IGNOREPROJECTOR
; Probably ignore the comments about matrix sources (which was inserted by
; shadertool) - doubtful the pixel shaders would have had the matrices anyway
