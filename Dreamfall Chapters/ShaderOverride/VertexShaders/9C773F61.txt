// CRC32: 9C773F61 |    Unity headers extracted from Unlit - Premultiplied Colored.shader
//    Shader "Unlit/Premultiplied Colored" {
//      Properties {
//       _MainTex ("Base (RGB), Alpha (A)", 2D) = "black" { }
//      }
//      SubShader 1/2 {
//        LOD 200
//        Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }
//        Pass 1/1 {
//          Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }
//          ZWrite Off
//          Cull Off
//          Blend One OneMinusSrcAlpha
//          ColorMask RGB
//          Offset -1, -1
//          GpuProgramID 15950
//          Program "vp" {
//            SubProgram "d3d9 " {
//              GpuProgramIndex 0
//            }
//          }
//        }
//      }
//    }
//
// Unity 5.3 headers extracted from Unlit - Premultiplied Colored.shader.decompressed:
//   API d3d9
//   Shader model vs_2_0
//   undeciphered1: 6 -1 -1
//   undeciphered3: 13 3 0 0 2 1 3 4 1
//   Matrix 0 [glstate_matrix_mvp]
//
// Headers extracted with DarkStarSword's extract_unity53_shaders.py
// https://raw.githubusercontent.com/DarkStarSword/3d-fixes/master/extract_unity53_shaders.py

//
// Generated by Microsoft (R) HLSL Shader Compiler 6.3.9600.16384
//   using 3Dmigoto command line v1.2.36 on Sun Jun 19 22:01:32 2016
//
//
// Parameters:
//
//   row_major float4x4 glstate_matrix_mvp;
//
//
// Registers:
//
//   Name               Reg   Size
//   ------------------ ----- ----
//   glstate_matrix_mvp c0       4
//

    vs_3_0 // Converted from vs_2_0 with DarkStarSword's shadertool.py
    dcl_position v0
    dcl_color v1
    dcl_texcoord v2

dcl_texcoord o0
dcl_position o1
dcl_color o2

def c220, 0, 1, 0.0625, 0.5
dcl_2d s0

// For the auto HUD depth:
dcl_2d s3 // Copy of _CameraDepthTexture
defi i0, 255, 0, 0, 0
def c227, 0.00390625, 64, 0, 0.5 // 1/i0.x, 0.5

    dp4 r0.x, c0, v0
    dp4 r0.y, c1, v0
    dp4 r0.z, c2, v0
    dp4 r0.w, c3, v0
    mov o2, v1
    mov o0.xy, v2

// Check W == 1 to prevent double adjusting choice text:
if_eq r0.w, c220.y
	texldl r31, c220.z, s0

	mov r31.w, c200.y
	if_eq r31.w, c220.y
		// Auto depth: sample a number of points on the depth buffer to
		// determine an appropriate depth for this object, starting at the near
		// clipping plane and working towards original x + separation.
		//
		// You can think of this as a line in three dimensional space that
		// starts at each eye and stretches out towards infinity. We sample 255
		// points along this line (evenly spaced in the X axis) and compare
		// with the depth buffer to find where the line is first intersected.
		//
		// Based on DarkStarSword's stereo crosshair code originally developed
		// for Miasmata, adapted to HLSL and made to use coordinates other than
		// (0,0), then adapted back to assembly for UE3.

		// Screen depth coordinates to sample around - Using the first
		// vertex position obtained with Helix Mod. Would be better to
		// use the center, but I don't think it is possible to look
		// that up in Helix Mod (would need to get the possition of a
		// diagonally opposite vertex).
		mov r23, c170
		dp4 r22.x, c0, r23
		dp4 r22.y, c1, r23

		// near clipping plane - for Unity we get this from _ZBufferParams
		rcp r20.w, c150.w

		// offset = separation * (near - convergence) / near
		add r31.w, r20.w, -r31.y
		mul r20.x, r31.w, r31.x
		rcp r31.w, r20.w
		mul r20.x, r20.x, r31.w

		// Total distance to cover
		// distance = separation - starting X offset:
		add r20.y, r31.x, -r20.x

		// old_offset = offset
		mov r21.x, r20.x

		// Precompute some constants:
		// separation * convergence:
		mul r31.w, r31.x, r31.y
		// distance / 255:
		mul r20.z, r20.y, c227.x

		rep i0
			// offset += distance / 255:
			add r20.x, r20.x, r20.z

			// Calculate W for this adjustment amount:
			// w = (separation * convergence) / (separation - offset):
			add r20.w, r31.x, -r20.x
			rcp r20.w, r20.w
			mul r20.w, r31.w, r20.w

			// sample_x = x + offset, sample_y = y (not flipped compared to UE3)
			mov r23.y, r22.y
			add r23.x, r22.x, r20.x
			// Convert to texture coordinates (coords / 2 + 0.5):
			mad r23.xy, r23.xy, c220.w, c220.w
			// Sample depth buffer:
			texldl r5, r23.xy, s3

			// scale depth buffer to world Z (game dependent - look for scaling applied to
			// the depth buffer wherever else it is used. In the case of Unity we use
			// _ZBufferParams):
			mad r5.x, r5.x, c150.x, c150.y
			add r5.y, c150.z, c150.w // Derive 1/far from _ZBufferParams
			mul r5.x, r5.x, r5.y
			rcp r5.x, r5.x

			// If the sampled depth is closer than the calculated depth, exit the loop:
			break_ge r20.w, r5.x

			// old_offset = offset
			mov r21.x, r20.x
		endrep

		// Finally adjust the X coordinate:
		add r0.x, r0.x, r21.x
	else
		// UI depth adjustment inserted with DarkStarSword's shadertool.py:
		// shadertool.py --ui=c200.z -i VertexShader_58_CRC32_6AEB3DDF.txt
		mad r0.x, r31.x, c200.z, r0.x

	endif

endif

mov o1, r0

// approximately 6 instruction slots used
