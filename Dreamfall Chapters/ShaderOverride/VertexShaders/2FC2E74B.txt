// HUD - floating icons

// CRC32: 2FC2E74B | Unity headers extracted from Unlit - Transparent Colored.shader
// Shader "Unlit/Transparent Colored" {
//   Properties {
//    _MainTex ("Base (RGB), Alpha (A)", 2D) = "black" { }
//   }
//   SubShader 1/2 {
//     LOD 100
//     Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }
//     Pass 1/1 {
//       Tags { "QUEUE"="Transparent" "IGNOREPROJECTOR"="true" "RenderType"="Transparent" }
//       ZWrite Off
//       Cull Off
//       Blend SrcAlpha OneMinusSrcAlpha
//       Offset -1, -1
//       GpuProgramID 19577
//       Program "vp" {
//         SubProgram "d3d9 " {
//           Bind "vertex" Vertex
//           Bind "color" Color
//           Bind "texcoord" TexCoord0
//           Matrix 0 [glstate_matrix_mvp]
//         }
//       }
//     }
//   }
// }
// 
// Headers extracted with DarkStarSword's extract_unity_shaders.py
// https://raw.githubusercontent.com/DarkStarSword/3d-fixes/master/extract_unity_shaders.py

// UI - full screen fade to black and others

    vs_3_0 // Converted from vs_2_0 with DarkStarSword's shadertool.py
    dcl_position v0
    dcl_texcoord v1
    dcl_color v2

dcl_texcoord o0
dcl_position o1
dcl_color o2


def c220, 0, 1, 0.0625, 0.5
def c221, 1920, 1080, 0.0005208333333333333, 0.000925925925
dcl_2d s0

// For the auto HUD depth:
dcl_2d s3 // Copy of _CameraDepthTexture
defi i0, 255, 0, 0, 0
def c227, 0.00390625, 64, 0, 0.5 // 1/i0.x, 0.5

    dp4 r0.x, c0, v0
    dp4 r0.y, c1, v0
    dp4 r0.z, c2, v0
    dp4 r0.w, c3, v0
    mov o0.xy, v1
    mov o2, v2

// Determine an appropriate threshold coordinates near the corners for the
// current resolution (1 - 2/resolution):
rcp r30.z, c210.x		// Instruction can only operate on one component at a time
rcp r30.w, c210.y		// And c210.zw doesn't seem to already be the reciprocal
add r30.xy, r30.zwzw, r30.zwzw	// 2/resolution
add r30.xy, c220.y, -r30.xy	// 1 - 2/resolution

// Blacklist full screen coordinates at/beyond the screen corners:
abs r31.xy, r0.xy
mov r30.w, c220.y
if_ge r31.x, r30.x
	if_ge r31.y, r30.y
		mov r30.w, c220.x
		// Uncomment to remove full screen textures to make it easier
		// to see while paused:
		//mov r30.w, c220.w
	endif
endif

// Check W == 1 to avoid double adjusting some icons (choice/balance icons)
if_ne r0.w, c220.y
	mov r30.w, c220.x
endif

if_eq r30.w, c220.y
	texldl r31, c220.z, s0

	mov r31.w, c200.y
	if_eq r31.w, c220.y
		// Auto depth: sample a number of points on the depth buffer to
		// determine an appropriate depth for this object, starting at the near
		// clipping plane and working towards original x + separation.
		//
		// You can think of this as a line in three dimensional space that
		// starts at each eye and stretches out towards infinity. We sample 255
		// points along this line (evenly spaced in the X axis) and compare
		// with the depth buffer to find where the line is first intersected.
		//
		// Based on DarkStarSword's stereo crosshair code originally developed
		// for Miasmata, adapted to HLSL and made to use coordinates other than
		// (0,0), then adapted back to assembly for UE3.

		// Screen depth coordinates to sample around - Using the first
		// vertex position obtained with Helix Mod. Would be better to
		// use the center, but I don't think it is possible to look
		// that up in Helix Mod (would need to get the possition of a
		// diagonally opposite vertex).
		mov r23, c170
		dp4 r22.x, c0, r23
		dp4 r22.y, c1, r23

		// near clipping plane - for Unity we get this from _ZBufferParams
		rcp r20.w, c150.w

		// offset = separation * (near - convergence) / near
		add r31.w, r20.w, -r31.y
		mul r20.x, r31.w, r31.x
		rcp r31.w, r20.w
		mul r20.x, r20.x, r31.w

		// Total distance to cover
		// distance = separation - starting X offset:
		add r20.y, r31.x, -r20.x

		// old_offset = offset
		mov r21.x, r20.x

		// Precompute some constants:
		// separation * convergence:
		mul r31.w, r31.x, r31.y
		// distance / 255:
		mul r20.z, r20.y, c227.x

		rep i0
			// offset += distance / 255:
			add r20.x, r20.x, r20.z

			// Calculate W for this adjustment amount:
			// w = (separation * convergence) / (separation - offset):
			add r20.w, r31.x, -r20.x
			rcp r20.w, r20.w
			mul r20.w, r31.w, r20.w

			// sample_x = x + offset, sample_y = y (not flipped compared to UE3)
			mov r23.y, r22.y
			add r23.x, r22.x, r20.x
			// Convert to texture coordinates (coords / 2 + 0.5):
			mad r23.xy, r23.xy, c220.w, c220.w
			// Sample depth buffer:
			texldl r5, r23.xy, s3

			// scale depth buffer to world Z (game dependent - look for scaling applied to
			// the depth buffer wherever else it is used. In the case of Unity we use
			// _ZBufferParams):
			mad r5.x, r5.x, c150.x, c150.y
			add r5.y, c150.z, c150.w // Derive 1/far from _ZBufferParams
			mul r5.x, r5.x, r5.y
			rcp r5.x, r5.x

			// If the sampled depth is closer than the calculated depth, exit the loop:
			break_ge r20.w, r5.x

			// old_offset = offset
			mov r21.x, r20.x
		endrep

		// Finally adjust the X coordinate:
		add r0.x, r0.x, r21.x
	else
		// UI depth adjustment inserted with DarkStarSword's shadertool.py:
		// shadertool.py --ui=c200.z -i VertexShader_59_CRC32_2FC2E74B.txt
		mad r0.x, r31.x, c200.z, r0.x
	endif
endif
if_eq r30.w, c220.w
	mov r0, c220.x
endif

mov o1, r0
