// Shader identified as Unity "Hidden/Internal-PrePassLighting"
// Point lights near bed

// Headers extracted from Unity:

// Shader "Hidden/Internal-PrePassLighting" {
// Properties {
//  _LightTexture0 ("", any) = "" {}
//  _LightTextureB0 ("", 2D) = "" {}
//  _ShadowMapTexture ("", any) = "" {}
// }
// SubShader { 
//  Pass {
//   Tags { "SHADOWSUPPORT"="true" }
//   ZWrite Off
//   Fog { Mode Off }
//   Blend One One
// Program "fp" {
// SubProgram "d3d9 " {
// Keywords { "SPOT" "SHADOWS_OFF" "SUNSHINE_DISABLED" } // Same shader matched other sunshine variants
// Matrix 0 [_CameraToWorld]
// Matrix 4 [_LightMatrix0]
// Vector 8 [_WorldSpaceCameraPos]
// Vector 9 [_ProjectionParams]
// Vector 10 [_ZBufferParams]
// Vector 11 [unity_ShadowFadeCenterAndType]
// Vector 12 [_LightPos]
// Vector 13 [_LightColor]
// Vector 14 [unity_LightmapFade]
// SetTexture 0 [_CameraNormalsTexture] 2D 0
// SetTexture 1 [_CameraDepthTexture] 2D 1
// SetTexture 2 [_LightTexture0] 2D 2
// SetTexture 3 [_LightTextureB0] 2D 3

    ps_3_0
    dcl_2d s0 // _CameraNormalsTexture
    dcl_2d s1 // _CameraDepthTexture
    dcl_2d s2 // _LightTexture0
    dcl_2d s3 // _LightTextureB0
    def c15, 1, 2, -1, 0
    def c16, 128, 0.219970703, 0.70703125, 0.0709838867
    dcl_texcoord v0      // From VS: ComputeScreenPos(o.pos)
    dcl_texcoord1 v1.xyz // From VS: lerp(mul(MV, v.vertex).xyz * (-1,-1,1), v.normal, _LightAsQuad)

def c220, 0, 0.85, 0.0625, 0.5
dcl_2d s13

// float2 uv = i.uv.xy / i.uv.w
    rcp r0.x, v0.w
    mul r0.xy, v0, r0.x

// float depth = SAMPLE_DEPTH_TEXTURE(_CameraDepthTexture, uv);
    texld r1.x, r0, s1

// i.ray = i.ray * (_ProjectionParams.z / i.ray.z);
//                                     ^^^^^^^^^^
    rcp r0.z, v1.z

// float4 vpos = float4(i.ray * depth,1);
//                                   ^^^
    mov r3.z, c15.x

// depth = 1.0 / (_ZBufferParams.x * depth + _ZBufferParams.y);
//                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    mad r0.w, r1.x, c10.x, c10.y

// i.ray = i.ray * (_ProjectionParams.z / i.ray.z);
    mul r0.z, r0, c9
    mul r1.xyz, v1, r0.z

// depth = 1.0 / (_ZBufferParams.x * depth + _ZBufferParams.y);
    rcp r0.z, r0.w

// float4 vpos = float4(i.ray * depth,1);
    mul r3.xyw, r1.xyzz, r0.z  // View-space coord using .xyw -> Depth is in r3.w

// We need to get the horizontal FOV, which is in the projection matrix at
// [0,0] (well, actually it's cot(fov_h / 2), but that's what we need).
//
// Unfortunately none of the Unity shaders use the projection matrix, so we
// need to calculate it. We have the MVP matrix in c190 and the inverted MV
// matrix in c180, which was copied from the VS with Helix mod (refer to the
// DX9Settings.ini).
//
// We can calculate the projection matrix by multiplying the inverted MV matrix
// by the MVP matrix: P = MV.I * MVP
//
// Since we only need one field in the projection matrix, we can avoid doing a
// full matrix multiplication here. We only need to multiply the first row of
// the inverted MV matrix with the first column of the MVP matrix. The matrix
// regs are columns (I think - feels backwards to me), which means we need to
// transpose the first component of each of the MV regs into a temporary
// register to get it's first row:
mov r21.x, c180.x
mov r21.y, c181.x
mov r21.z, c182.x
mov r21.w, c183.x
// Now calculate the dot product of the first row of MV.I with the first column
// of MVP and store the result in r20.x - this is Projection[0,0]:
dp4 r20.x, r21, c190

// We need to divide by the FOV, so invert it:
rcp r20.x, r20.x

// And now we can adjust the shadow:
texldl r31, c220.z, s13 // r31.x = separation, r31.y = convergence
add r31.w, r3.w, -r31.y // r31.w = depth - convergence
mul r31.w, r31.w, r31.x // r31.w = separation * (depth - convergence)
mul r31.w, r31.w, r20.x // Adjust by FOV we just calculated
add r3.x, r3.x, -r31.w  // Finally adjust the X coord

// float3 wpos = mul(_CameraToWorld, vpos).xyz
    dp4 r2.x, r3.xywz, c0
    dp4 r2.z, r3.xywz, c2
    dp4 r2.y, r3.xywz, c1

// Wow, really? Three instructions where a single 'mov r1.xyz, r2' would have sufficed.
// r1 is a copy of wpos
    mov r1.x, r2
    mov r1.z, r2
    mov r1.y, r2

// half3 h = normalize (lightDir - normalize(wpos-_WorldSpaceCameraPos));
//                                           ^^^^^^^^^^^^^^^^^^^^^^^^^
    add r4.xyz, r1, -c8

// float3 tolight = _LightPos.xyz - wpos;
    add r3.xyz, -r1, c12

// half3 h = normalize (lightDir - normalize(wpos-_WorldSpaceCameraPos));
//                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ?
    dp3 r2.w, r4, r4

// float att = dot(tolight, tolight) * _LightPos.w;    ?
//             ^^^^^^^^^^^^^^^^^^^^^                   ?
    dp3 r1.w, r3, r3
// half3 lightDir = normalize (tolight);               ?
    rsq r0.z, r1.w
    mul r3.xyz, r0.z, r3

//half4 nspec = tex2D (_CameraNormalsTexture, uv);
    texld r0, r0, s0

//half3 normal = nspec.rgb * 2 - 1;
    mad_pp r5.xyz, r0, c15.y, c15.z

// half3 h = normalize (lightDir - normalize(wpos-_WorldSpaceCameraPos));
//                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    ?
    rsq r2.w, r2.w
    mad r0.xyz, -r2.w, r4, r3

// normal = normalize(normal);
    dp3_pp r4.x, r5, r5

// half3 h = normalize (lightDir - normalize(wpos-_WorldSpaceCameraPos));
    dp3 r2.w, r0, r0
    rsq r2.w, r2.w
    mul r0.xyz, r2.w, r0

// float4 uvCookie = mul (_LightMatrix0, float4(wpos,1));
//                                                  ^^^
    mov r2.w, c15.x

// normal = normalize(normal);
    rsq_pp r4.x, r4.x
    mul_pp r4.xyz, r4.x, r5

// float spec = pow (max (0, dot(h,normal)), nspec.a*128.0);
    dp3_pp r0.y, r0, r4
    mul_pp r0.x, r0.w, c16
    max_pp r0.y, r0, c15.w
    pow_pp r5, r0.y, r0.x

// float4 uvCookie = mul (_LightMatrix0, float4(wpos,1));
    dp4 r4.w, r2, c7
    dp4 r0.z, r2, c6
    dp4 r0.x, r2, c4
    dp4 r0.y, r2, c5
    mov r0.w, r4

// float atten = tex2Dproj (_LightTexture0, UNITY_PROJ_COORD(uvCookie)).w;
    texldp r0.w, r0, s2

// float att = dot(tolight, tolight) * _LightPos.w;
    mul r0.x, r1.w, c12.w

// atten *= uvCookie.w < 0;
    cmp r0.y, r4.w, c15.w, c15.x
    mul r0.y, r0.w, r0

// atten *= tex2D (_LightTextureB0, att.rr).UNITY_ATTEN_CHANNEL;
    texld r0.x, r0.x, s3
    mul r0.w, r0.y, r0.x

// Things start to get harder to follow below here as the compiler has
// re-oredered and inter-mixed some of the multiplications

// float sphereDist = distance(wpos, unity_ShadowFadeCenterAndType.xyz);
    add r0.xyz, -r1, c11
    dp3 r1.y, r0, r0

// half4 res.xyz = _LightColor.rgb * (diff * atten);
//                 ^^^^^^^^^^^^^^^
    mov_pp r0.xyz, c13

// Converts color to luminance (grayscale)
// inline fixed Luminance( fixed3 c ) {
// 	return dot( c, fixed3(0.22, 0.707, 0.071) );
// res.w = spec * Luminance (_LightColor.rgb);
//                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    dp3_pp r0.x, c16.yzww, r0

// float fadeDist = lerp(z, sphereDist, unity_ShadowFadeCenterAndType.w);  ?
    rsq r1.y, r1.y
    rcp r0.y, r1.y
    add r0.y, -r3.w, r0                           // hmmm, isn't r3.w still depth?
    mad r0.y, r0, c11.w, r3.w                     //

// float fade = fadeDist * unity_LightmapFade.z + unity_LightmapFade.w;
    mad r0.y, r0, c14.z, c14.w

// spec *= saturate(atten);
//         ^^^^^^^^^^^^^^^
    mov_sat r1.w, r0
    mov_pp r2.x, r5
    mul r1.x, r2, r1.w

// res.w = spec * Luminance (_LightColor.rgb);
    mul r1.w, r1.x, r0.x

// half diff = max (0, dot (lightDir, normal));
    dp3_pp r0.x, r3, r4
    max_pp r0.x, r0, c15.w

// res.xyz = _LightColor.rgb * (diff * atten);
//                              ^^^^^^^^^^^^^
    mul r0.x, r0.w, r0

// res *= saturate(1.0-fade);
    add_sat r0.y, -r0, c15.x

// Finishing up the _LightColor.rgb multiplication which the compiler split up?
    mul r1.xyz, r0.x, c13
    mul_pp oC0, r1, r0.y

// approximately 69 instruction slots used (4 texture, 65 arithmetic)
