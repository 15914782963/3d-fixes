// Lensflares

cbuffer cVSObject : register(b5)
{

  struct
  {
    float4x4 m_viewWorld;
    float4x4 m_world;
    float4 m_useWeightCount;
    float4 m_localParam[4];
  } g_vsObject : packoffset(c0);

}

cbuffer cVSLight : register(b3)
{

  struct
  {
    float4 m_lightParams[11];
  } g_vsLight : packoffset(c0);

}

cbuffer cVSWork : register(b7)
{

  struct
  {
    float4x4 m_viewInverse;
    float4x4 m_matrix[8];
  } g_vsWork : packoffset(c0);

}



// 3Dmigoto declarations
#define cmp -
Texture1D<float4> IniParams : register(t120);
Texture2D<float4> StereoParams : register(t125);


void main( 
  float3 v0 : POSITION0,
  float4 v1 : COLOR0,
  float2 v2 : TEXCOORD0,
  out float4 o0 : COLOR1,
  out float2 o1 : TEXCOORD0,
  out float p1 : TEXCOORD2,
  out float4 o2 : TEXCOORD1,
  out float3 o3 : TEXCOORD3,
  out float4 o4 : SV_Position0)
{
  float4 r0,r1,r2,r3,r4,r5,r6;
  uint4 bitmask, uiDest;
  float4 fDest;

  r0.xyzw = v1.xyzw;
  r1.x = v0.z;
  r1.y = 0;
  r1.z = cmp(r1.x < 0);
  if (r1.z != 0) {
    r1.y = 1;
    r1.x = -1 * r1.x;
  }
  r1.x = r1.x;
  r1.zw = v2.xy;
  r2.xyzw = g_vsLight.m_lightParams[2].xyzw;
  r3.xyz = g_vsObject.m_localParam[0].xyz;
  r4.xyz = g_vsObject.m_localParam[1].xyz;
  r5.xy = v0.xy;
  r5.zw = float2(0,1);

  // Correct lens flare placement
  float4 stereo = StereoParams.Load(0);
  float depth = v0.z;
  float adj;
  if (depth < 0) { // Depth is invalid, move to infinity:
	  adj = stereo.x / 2;
  } else { // Valid depth, use it:
	  adj = stereo.x * (depth - stereo.y) / depth / 2;
  }
  r5.x += adj; // placement
  r0.x += adj; // opacity (to be confirmed)

  r6.x = dot(r5.xyzw, g_vsWork.m_matrix[0]._m00_m10_m20_m30);
  r6.y = dot(r5.xyzw, g_vsWork.m_matrix[0]._m01_m11_m21_m31);
  r6.z = dot(r5.xyzw, g_vsWork.m_matrix[0]._m02_m12_m22_m32);
  r6.w = dot(r5.xyzw, g_vsWork.m_matrix[0]._m03_m13_m23_m33);
  r3.xyz = r6.xyz * r3.xyz;
  r6.xyz = r3.xyz + r4.xyz;
  r3.x = r1.z / 16;
  r3.x = floor(r3.x);
  r4.x = 0.0666666701 * r3.x;
  r3.x = 16 * r3.x;
  r3.x = -r3.x;
  r3.x = r3.x + r1.z;
  r3.x = floor(r3.x);
  r4.y = 0.0666666701 * r3.x;
  r3.x = floor(r1.z);
  r3.x = -r3.x;
  r1.z = r3.x + r1.z;
  r4.z = 1.06666672 * r1.z;
  r4.w = r0.w;
  r0.w = floor(r1.w);
  r1.z = 0.0322580636 * r0.w;
  r3.x = -r0.w;
  r1.w = r3.x + r1.w;
  r3.x = 2 * r1.w;
  r3.x = 3.14159274 * r3.x;
  r3.x = 1.01587307 * r3.x;
  r1.z = 0.5 * r1.z;
  r3.y = cos(r3.x);
  r3.y = r3.y * r1.z;
  r5.x = 0.5 + r3.y;
  r3.x = sin(r3.x);
  r1.z = r3.x * r1.z;
  r5.y = 0.5 + r1.z;
  r3.x = 0.0158730168 * r0.w;
  r3.y = 1.01587307 * r1.w;
  r1.zw = r5.xy * r1.yy;
  r0.w = -r1.y;
  r0.w = 1 + r0.w;
  r3.xy = r3.xy * r0.ww;
  r1.yz = r3.xy + r1.zw;
  o4.xyzw = r6.xyzw;
  o2.xyzw = r4.xyzw;
  o0.xyzw = r2.xyzw;
  o1.xy = r1.yz;
  o3.xyz = r0.xyz;
  p1.x = r1.x;
  return;
}

/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Generated by Microsoft (R) HLSL Shader Compiler 9.29.952.3111
//
//   using 3Dmigoto v1.2.25 on Tue Jan 19 09:37:32 2016
//
//
// Buffer Definitions: 
//
// cbuffer cVSObject
// {
//
//   struct VSObject
//   {
//       
//       float4x4 m_viewWorld;          // Offset:    0
//       float4x4 m_world;              // Offset:   64
//       float4 m_useWeightCount;       // Offset:  128
//       float4 m_localParam[4];        // Offset:  144
//
//   } g_vsObject;                      // Offset:    0 Size:   208
//
// }
//
// cbuffer cVSLight
// {
//
//   struct VSLight
//   {
//       
//       float4 m_lightParams[11];      // Offset:    0
//
//   } g_vsLight;                       // Offset:    0 Size:   176
//
// }
//
// cbuffer cVSWork
// {
//
//   struct VSWork
//   {
//       
//       float4x4 m_viewInverse;        // Offset:    0
//       float4x4 m_matrix[8];          // Offset:   64
//
//   } g_vsWork;                        // Offset:    0 Size:   576
//
// }
//
//
// Resource Bindings:
//
// Name                                 Type  Format         Dim Slot Elements
// ------------------------------ ---------- ------- ----------- ---- --------
// cVSLight                          cbuffer      NA          NA    3        1
// cVSObject                         cbuffer      NA          NA    5        1
// cVSWork                           cbuffer      NA          NA    7        1
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// POSITION                 0   xyz         0     NONE   float   xyz 
// COLOR                    0   xyzw        1     NONE   float   xyzw
// TEXCOORD                 0   xy          2     NONE   float   xy  
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// COLOR                    1   xyzw        0     NONE   float   xyzw
// TEXCOORD                 0   xy          1     NONE   float   xy  
// TEXCOORD                 2     z         1     NONE   float     z 
// TEXCOORD                 1   xyzw        2     NONE   float   xyzw
// TEXCOORD                 3   xyz         3     NONE   float   xyz 
// SV_Position              0   xyzw        4      POS   float   xyzw
//
vs_5_0
dcl_globalFlags refactoringAllowed
dcl_constantbuffer cb5[11], immediateIndexed
dcl_constantbuffer cb3[3], immediateIndexed
dcl_constantbuffer cb7[8], immediateIndexed
dcl_input v0.xyz
dcl_input v1.xyzw
dcl_input v2.xy
dcl_output o0.xyzw
dcl_output o1.xy
dcl_output o1.z
dcl_output o2.xyzw
dcl_output o3.xyz
dcl_output_siv o4.xyzw, position
dcl_temps 7

#line 130 "d:\work\master\git_clone\_intermediate\win64\TppShaders_dx11_win64\Release\Draw2D_TppLensFlare_vs.hlsl"
mov r0.xyzw, v1.xyzw  // inColor<0,1,2,3>

#line 134
mov r1.x, v0.z  // NRevisePosition_revisePosition_inPosition<2>
nop 
mov r1.x, r1.x  // inPosition<2>

#line 19
mov r1.y, l(0)  // outCircleShapeFlag<0: 0f>
lt r1.z, r1.x, l(0.000000)
if_nz r1.z
  mov r1.y, l(1.000000)  // outCircleShapeFlag<0: 1f>
  mul r1.x, r1.x, l(-1.000000)  // inPosition<2:[0f,3.40282e+038f]>
endif 

#line 25
mov r1.x, r1.x  // outPosition<2:[-0f,3.40282e+038f]>

#line 135
mov r1.x, r1.x  // NRevisePosition_revisePosition_outPosition<2:[-0f,3.40282e+038f]>
mov r1.y, r1.y  // NRevisePosition_revisePosition_outCircleShapeFlag<0:[-0f,1f]>
mov r0.xyzw, r0.xyzw  // NTransformInput2_transform_inColor<0,1,2,3>
mov r1.zw, v2.xxxy  // NTransformInput2_transform_inUV<0,1>
mov r1.y, r1.y  // NTransformInput2_transform_inCircleShapeFlag<0:[-0f,1f]>
nop 
mov r0.xyzw, r0.xyzw  // inColor<0,1,2,3>
mov r1.zw, r1.zzzw  // inUV<0,1>
mov r1.y, r1.y  // inCircleShapeFlag<0:[-0f,1f]>

#line 59
nop 

#line 38
mov r2.xyzw, cb3[2].xyzw  // GetTextureMask<0,1,2,3>

#line 59
mov r2.xyzw, r2.xyzw  // textureMask<0,1,2,3>
mov r3.xyz, cb5[9].xyzx  // viewMapScale<0,1,2>
mov r4.xyz, cb5[10].xyzx  // viewMapOffset<0,1,2>

#line 66
nop 

#line 408
mov r5.xy, v0.xyxx
mov r5.zw, l(0,0,0,1.000000)
dp4 r6.x, r5.xyzw, cb7[4].xyzw  // ApplyMatrixT<0:NaN:Inf>
dp4 r6.y, r5.xyzw, cb7[5].xyzw  // ApplyMatrixT<1:NaN:Inf>
dp4 r6.z, r5.xyzw, cb7[6].xyzw  // ApplyMatrixT<2:NaN:Inf>
dp4 r6.w, r5.xyzw, cb7[7].xyzw  // ApplyMatrixT<3:NaN:Inf>

#line 66
mov r6.xyzw, r6.xyzw  // outPosition<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
mul r3.xyz, r3.xyzx, r6.xyzx
add r6.xyz, r4.xyzx, r3.xyzx  // outPosition<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>

#line 75
div r3.x, r1.z, l(16.000000)
round_ni r3.x, r3.x  // colR<0:[-2.12676e+037f,2.12676e+037f]>
mul r4.x, r3.x, l(0.066667)  // outColor<0:[-1.41784e+036f,1.41784e+036f]>
mul r3.x, r3.x, l(16.000000)
mov r3.x, -r3.x
add r3.x, r1.z, r3.x
round_ni r3.x, r3.x  // colG<0:Inf>
mul r4.y, r3.x, l(0.066667)  // outColor<1:[-4.5371e+037f,4.5371e+037f]>
round_ni r3.x, r1.z
mov r3.x, -r3.x
add r1.z, r1.z, r3.x
mul r4.z, r1.z, l(1.066667)  // outColor<2:Inf>
mov r4.w, r0.w  // outColor<3>

#line 89
round_ni r0.w, r1.w
mul r1.z, r0.w, l(0.032258)  // scale<0:[-1.09769e+037f,1.09769e+037f]>
mov r3.x, -r0.w
add r1.w, r1.w, r3.x
mul r3.x, r1.w, l(2.000000)
mul r3.x, r3.x, l(3.141593)
mul r3.x, r3.x, l(1.015873)  // rot<0:Inf>
mul r1.z, r1.z, l(0.500000)
sincos null, r3.y, r3.x
mul r3.y, r1.z, r3.y
add r5.x, r3.y, l(0.500000)  // circleUV<0:[-5.48843e+036f,5.48843e+036f]>
sincos r3.x, null, r3.x
mul r1.z, r1.z, r3.x
add r5.y, r1.z, l(0.500000)  // circleUV<1:[-5.48843e+036f,5.48843e+036f]>

#line 98
mul r3.x, r0.w, l(0.015873)  // outUV<0:[-5.40131e+036f,5.40131e+036f]>
mul r3.y, r1.w, l(1.015873)  // outUV<1:Inf>
mul r1.zw, r1.yyyy, r5.xxxy
mov r0.w, -r1.y
add r0.w, r0.w, l(1.000000)
mul r3.xy, r0.wwww, r3.xyxx
add r1.yz, r1.zzwz, r3.xxyx  // outUV<0:[-1.08897e+037f,1.08897e+037f],1:NaN:Inf>
mov r2.xyzw, r2.xyzw  // outMask<0,1,2,3>
mov r0.xyz, r0.xyzx  // outZTestParam<0,1,2>

#line 139
mov r6.xyz, r6.xyzx  // NTransformInput2_transform_outPosition<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf>
mov r6.w, r6.w  // NTransformInput2_transform_outPosition<3:NaN:Inf>
mov r4.x, r4.x  // NTransformInput2_transform_outColor<0:[-1.41784e+036f,1.41784e+036f]>
mov r4.y, r4.y  // NTransformInput2_transform_outColor<1:[-4.5371e+037f,4.5371e+037f]>
mov r4.z, r4.z  // NTransformInput2_transform_outColor<2:Inf>
mov r4.w, r4.w  // NTransformInput2_transform_outColor<3>
mov r2.xyzw, r2.xyzw  // NTransformInput2_transform_outMask<0,1,2,3>
mov r1.yz, r1.yyzy  // NTransformInput2_transform_outUV<0:[-1.08897e+037f,1.08897e+037f],1:NaN:Inf>
mov r0.xyz, r0.xyzx  // NTransformInput2_transform_outZTestParam<0,1,2>
mov o4.xyzw, r6.xyzw  // outPosition<0:NaN:Inf,1:NaN:Inf,2:NaN:Inf,3:NaN:Inf>
mov o2.xyzw, r4.xyzw  // outColor<0:[-1.41784e+036f,1.41784e+036f],1:[-4.5371e+037f,4.5371e+037f],2:Inf,3>
mov o0.xyzw, r2.xyzw  // outMask<0,1,2,3>
mov o1.xy, r1.yzyy  // outUV<0:[-1.08897e+037f,1.08897e+037f],1:NaN:Inf>
mov o3.xyz, r0.xyzx  // outZTestParam<0,1,2>
mov o1.z, r1.x  // outLightDepth<0:[-0f,3.40282e+038f]>

#line 117
ret 
// Approximately 87 instruction slots used

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/
