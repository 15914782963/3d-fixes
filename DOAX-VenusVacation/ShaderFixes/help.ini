[KeyHelp]
key = F1
type = toggle
run = CommandListHelp
[CommandListHelp]
; The pre commands run when the F1 key is first pressed. Set the current help
; text to the full help text and run the formatting shader
pre ResourceHelp = ref ResourceHelpFull
pre ResourceParams = ref ResourceParamsFull
pre run = CustomShaderFormatHelp
; Setting the short help text to null disables the timeout in the present
; command list:
pre ResourceHelpShort = null
; The post commands run when the help key is pressed again. Set the current
; help text to null to disable the help shader:
post ResourceHelp = null

[Constants]
; The Constants command list is used for initialisation on application load
; time and after config reload. We set up the short help message here:
ResourceHelp = ref ResourceHelpShort
ResourceParams = ref ResourceParamsShort

[Present]
if ResourceHelp !== null
	if window_width != x5 || window_height != y5
		; Resolution changed, reformat text
		x5 = window_width
		y5 = window_height
		run = CustomShaderFormatHelp
	endif
	run = CustomShaderRenderHelp

	; Automatically clear the short help prompt a few seconds after
	; launching the game
	if ResourceHelpShort !== null && time > 10.0
		ResourceHelpShort = null
		ResourceHelp = null
	endif
endif

; Custom resources that load the long and short help text from file:
[ResourceHelpFull]
type = buffer
format = R8_UINT
filename = help.txt
; Because this resource is never bound directly (only through ResourceHelp)
; 3DMigoto cannot automatically determine the bind flags. To allow it to be
; used in a texture slot it must have the shader_resource bind flag:
bind_flags = shader_resource
[ResourceHelpShort]
type = buffer
format = R8_UINT
filename = help_short.txt
bind_flags = shader_resource

; Using these parameter buffers as a way to pass in constant parameters without
; taking up any of the IniParams slots while still allowing the parameters to
; be customised on a per-message basis.
[ResourceParamsFull]
type = StructuredBuffer
array = 1
bind_flags = shader_resource
data = R32_FLOAT -0.8 0.9 0.8 -1 1 0.7 0.15 1 0 0 0 0.75 0.01 0.01 2 1 1.0
;                ^^^^Rectangle^^|^^^Colour^^^|Background|^Border^^|^ ^|^-- font scale
;                x1   y1  x2  y2|r g   b    a|r g b a   |horz vert| ^--- h/v-anchor: 0=none 1=left/top 2=center 3=right/bottom
[ResourceParamsShort]
type = StructuredBuffer
array = 1
bind_flags = shader_resource
data = R32_FLOAT -0.93 -0.9 +1 -0.9 1 0.7 0.15 1 0 0 0 0.75 0.01 0.01 1 3 1.0
;                ^Bounds Rectangle^|^^^Colour^^^|Background|^Border^^|^ ^|^-- font scale
;                x1    y1   x2 y2  |r g   b    a|r g b a   |horz vert| ^--- h/v-anchor: 0=none 1=left/top 2=center 3=right/bottom

; These resources hold the currently displayed help text and parameters. When
; ResourceHelp is null the shader will not be run:
[ResourceHelp]
[ResourceParams]

[ResourceFont]
; Note that this font has the size of each character embedded in the unused
; space of the final character, which the geometry shader uses to render each
; character the correct width. This font was generated with gen_bm_font.py,
; then converted to DDS (because our PNG loading seems to be broken o_O):
filename = LiberationSans-Bold.dds

[ResourceCS2GS]
; A buffer passed from the formatting compute shader to the geometry shader,
; indicating which shader invocation draws which text at what position.
type = StructuredBuffer
stride = 16
array = 4096

[ResourceCS2GSRef]

[CustomShaderFormatHelp]
; The compute shader scans the text and breaks it up into smaller chunks for
; each geometry shader invocation to render (max 64 characters each),
; calculating the position on the screen where each chunk of text is positioned
; wrapping long lines as needed. This is only run when necessary, not every
; frame.
cs = help.hlsl

cs-t113 = ResourceHelp
post cs-t113 = null
cs-t114 = ResourceParams
post cs-t114 = null

cs-t100 = ResourceFont
post cs-t100 = null

clear = ResourceCS2GS
cs-u0 = ResourceCS2GS
post cs-u0 = null

dispatch = 1, 1, 1

post ResourceCS2GSRef = ref ResourceCS2GS

[CustomShaderRenderHelp]
; The vertex shader passes draw indexes to the geometry shader:
vs = help.hlsl
; The geometry shader generates the text for a given draw index:
gs = help.hlsl
; The pixel shader draws the font:
ps = help.hlsl
; Allows us to use SV_Position.z to pack a texcoord, increasing the character
; limit per geometry shader invocation:
depth_clip_enable = false
cull = none
; Enable alpha blending. To change the text colour, edit the pixel shader:
blend = add one inv_src_alpha
; Use points as the primitive from the vertex shader to the geometry shader:
topology = point_list
run = CommandListUnbindAllRenderTargets
o0 = set_viewport no_view_cache bb
; Font is passed into the pixel shader (to draw it) *and* the geometry shader
; (as the character sizes are encoded in the final character of the font):
gs-t100 = ResourceFont
ps-t100 = ResourceFont
post gs-t100 = null
post ps-t100 = null
; Pass the help text to the geometry shader:
gs-t113 = ResourceHelp
post gs-t113 = null
; Pass the parameter buffer to the geometry and pixel shaders:
gs-t114 = ResourceParams
ps-t114 = ResourceParams
post gs-t114 = null
post ps-t114 = null
; Pass in the formatting information from the compute shader:
gs-t112 = ResourceCS2GS
post gs-t112 = null
; Change this number to limit how much text may be drawn:
draw = 4096, 0
